\hypertarget{gencurvefit_8c}{
\section{/Users/andrew/Documents/Andy/programming/libgencurvefit/src/gencurvefit.c File Reference}
\label{gencurvefit_8c}\index{/Users/andrew/Documents/Andy/programming/libgencurvefit/src/gencurvefit.c@{/Users/andrew/Documents/Andy/programming/libgencurvefit/src/gencurvefit.c}}
}
{\ttfamily \#include \char`\"{}gencurvefit.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}mt19937p.h\char`\"{}}\par
{\ttfamily \#include $<$stdlib.h$>$}\par
{\ttfamily \#include $<$time.h$>$}\par
{\ttfamily \#include \char`\"{}math.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}string.h\char`\"{}}\par
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef struct \hyperlink{gencurvefit_8c_a79671da3d1c7579cb7b69ed5b36d3038}{waveStats} \hyperlink{gencurvefit_8c_a79671da3d1c7579cb7b69ed5b36d3038}{waveStats}
\item 
typedef struct \hyperlink{gencurvefit_8c_a40d75df92f516c9bae852553127c44f3}{genoptStruct} \hyperlink{gencurvefit_8c_a40d75df92f516c9bae852553127c44f3}{genoptStruct}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void $\ast$ \hyperlink{gencurvefit_8c_a4cbd1f9b06be6e5d4f33e58b4d2cb134}{malloc2d} (int ii, int jj, int sz)
\item 
double \hyperlink{gencurvefit_8c_a335a4f02a913cc610bc39e6f6ede5cfc}{gnoise} (struct \hyperlink{structmt19937p}{mt19937p} $\ast$myMT19937, double sd)
\item 
int \hyperlink{gencurvefit_8c_ae2b325ec90b9cad5ca726d96d7a277e5}{genetic\_\-optimisation} (\hyperlink{gencurvefit_8h_a7a7ea9c36bfca151fe1556d1f5e61c26}{fitfunction} fitfun, \hyperlink{gencurvefit_8h_a655dc6f3bd77f814c6127a0556709cfe}{costfunction} costfun, unsigned int numcoefs, double $\ast$coefs, const unsigned int $\ast$holdvector, const double $\ast$$\ast$limits, long datapoints, const double $\ast$ydata, const double $\ast$$\ast$xdata, const double $\ast$edata, unsigned int numDataDims, double $\ast$chi2, const \hyperlink{structgencurvefit_options}{gencurvefitOptions} $\ast$gco, void $\ast$userdata)
\item 
double \hyperlink{gencurvefit_8c_a4b14e8f032e637096d2f1e3327f8e4a8}{chisquared} (void $\ast$userdata, const double $\ast$params, unsigned int numcoefs, const double $\ast$data, const double $\ast$model, const double $\ast$errors, long datapoints)
\item 
double \hyperlink{gencurvefit_8c_a12c9b16ff375eafa5ceff3ad8f783548}{robust} (void $\ast$userdata, const double $\ast$params, unsigned int numcoefs, const double $\ast$data, const double $\ast$model, const double $\ast$errors, long datapoints)
\end{DoxyCompactItemize}


\subsection{Typedef Documentation}
\hypertarget{gencurvefit_8c_a40d75df92f516c9bae852553127c44f3}{
\index{gencurvefit.c@{gencurvefit.c}!genoptStruct@{genoptStruct}}
\index{genoptStruct@{genoptStruct}!gencurvefit.c@{gencurvefit.c}}
\subsubsection[{genoptStruct}]{\setlength{\rightskip}{0pt plus 5cm}typedef struct {\bf genoptStruct} {\bf genoptStruct}}}
\label{gencurvefit_8c_a40d75df92f516c9bae852553127c44f3}
\hypertarget{gencurvefit_8c_a79671da3d1c7579cb7b69ed5b36d3038}{
\index{gencurvefit.c@{gencurvefit.c}!waveStats@{waveStats}}
\index{waveStats@{waveStats}!gencurvefit.c@{gencurvefit.c}}
\subsubsection[{waveStats}]{\setlength{\rightskip}{0pt plus 5cm}typedef struct {\bf waveStats} {\bf waveStats}}}
\label{gencurvefit_8c_a79671da3d1c7579cb7b69ed5b36d3038}


\subsection{Function Documentation}
\hypertarget{gencurvefit_8c_a4b14e8f032e637096d2f1e3327f8e4a8}{
\index{gencurvefit.c@{gencurvefit.c}!chisquared@{chisquared}}
\index{chisquared@{chisquared}!gencurvefit.c@{gencurvefit.c}}
\subsubsection[{chisquared}]{\setlength{\rightskip}{0pt plus 5cm}double chisquared (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{ userdata, }
\item[{const double $\ast$}]{ coefs, }
\item[{unsigned int}]{ numcoefs, }
\item[{const double $\ast$}]{ data, }
\item[{const double $\ast$}]{ model, }
\item[{const double $\ast$}]{ errors, }
\item[{long}]{ datapoints}
\end{DoxyParamCaption}
)}}
\label{gencurvefit_8c_a4b14e8f032e637096d2f1e3327f8e4a8}
a default chi2 cost function


\begin{DoxyParams}{Parameters}
\item[{\em userdata}]-\/ an (optional) pointer that is passed to the fitfunction, costfunction and updatefunction. Use this pointer to give extra information to your functions.\item[{\em coefs\mbox{[}numcoefs\mbox{]}}]-\/ an array containing the coefficients for the fit.\item[{\em numcoefs}]-\/ the number of parameters being fitted.\item[{\em data\mbox{[}datapoints\mbox{]}}]-\/ the data points being fitted.\item[{\em model\mbox{[}datapoints\mbox{]}}]-\/ the model values calculated by the fitfunction.\item[{\em errors\mbox{[}datapoints\mbox{]}}]-\/ the error bars (standard deviation) corresponding to each of the datapoints.\item[{\em datapoints}]-\/ the number of datapoints being fitted. \end{DoxyParams}
\hypertarget{gencurvefit_8c_ae2b325ec90b9cad5ca726d96d7a277e5}{
\index{gencurvefit.c@{gencurvefit.c}!genetic\_\-optimisation@{genetic\_\-optimisation}}
\index{genetic\_\-optimisation@{genetic\_\-optimisation}!gencurvefit.c@{gencurvefit.c}}
\subsubsection[{genetic\_\-optimisation}]{\setlength{\rightskip}{0pt plus 5cm}int genetic\_\-optimisation (
\begin{DoxyParamCaption}
\item[{{\bf fitfunction}}]{ fitfun, }
\item[{{\bf costfunction}}]{ costfun, }
\item[{unsigned int}]{ numcoefs, }
\item[{double $\ast$}]{ coefs, }
\item[{const unsigned int $\ast$}]{ holdvector, }
\item[{const double $\ast$$\ast$}]{ limits, }
\item[{long}]{ datapoints, }
\item[{const double $\ast$}]{ ydata, }
\item[{const double $\ast$$\ast$}]{ xdata, }
\item[{const double $\ast$}]{ edata, }
\item[{unsigned int}]{ numDataDims, }
\item[{double $\ast$}]{ chi2, }
\item[{const {\bf gencurvefitOptions} $\ast$}]{ gco, }
\item[{void $\ast$}]{ userdata}
\end{DoxyParamCaption}
)}}
\label{gencurvefit_8c_ae2b325ec90b9cad5ca726d96d7a277e5}
genetic\_\-optimisation -\/ perform curvefitting with differential evolution. Fitting is not limited to 1 independent variable, you can have as many as you like. The function is threadsafe as long as you supply unique copies of the inputs to each instance.


\begin{DoxyParams}{Parameters}
\item[{\em fitfun}]-\/ a function that calculates the dependent variable, given input parameters and independent variables. If you return a non-\/zero value from this function the fit will stop.\item[{\em costfun}]-\/ a function that calculates the costfunction to be minimised. This is normally a chi2 type function. i.e. sum (((model\mbox{[}i\mbox{]} -\/ data\mbox{[}i\mbox{]}) / dataerrors\mbox{[}i\mbox{]})$^\wedge$2 ) If costfun == NULL then a default chi2 function is used.\item[{\em numcoefs}]-\/ total number of fit parameters.\item[{\em coefs\mbox{[}numcoefs\mbox{]}}]-\/ an array containing all the parameters for the fit. After genetic\_\-optimisation this is populated by the parameters that best fit the data.\item[{\em holdvector\mbox{[}numcoefs\mbox{]}}]-\/ an array (with numcoefs elements) that specifies which parameters are going to be held during the fit. 0 = vary 1 = hold\item[{\em limits\mbox{[}2\mbox{]}\mbox{[}numcoefs\mbox{]}}]-\/ a 2D array which contains the lower and upper limits for each parameter. The lower limit must be lower than the upper limit, but only for those parameters that are being varied.\item[{\em datapoints}]-\/ the total number of data points in the fit.\item[{\em ydata\mbox{[}datapoints\mbox{]}}]-\/ an array containing the dependent variable (i.e. the data one is trying to fit).\item[{\em xdata\mbox{[}numDataDims\mbox{]}\mbox{[}datapoints\mbox{]}}]-\/ a 2D array containing the independent variables that correspond to each of the datapoints. One can fit multidimensional data, e.g. y = f(n, m). In this case numDataDims = 2. You can allocate a 2D dataset with m points using malloc2D(2, m, sizeof(double)). If you want to pass in a 1D dataset simply pass a pointer to the array. e.g. if your array is: double $\ast$xP; then pass in: \&xP BUT YOU HAVE TO REMEMBER TO DEREFERENCE THE POINTER IN THE FIT FUNCTION BEFORE YOU USE THE ARRAY. model\mbox{[}ii\mbox{]} = ($\ast$xP)\mbox{[}ii\mbox{]}\item[{\em edata\mbox{[}datapoints\mbox{]}}]-\/ an array containing the experimental uncertainties for each of the datapoints. If you use the default chi2 costfunction then it should contain standard deviations. Set each element to 1 if you do not wish to weight the fit by the experimental uncertainties.\item[{\em numDataDims}]-\/ the number of independent variables in the fit. For y = f(x) numDataDims = 1. For y = f(n, m), numDataDims = 2, etc.\item[{\em chi2}]-\/ the final value of the cost function.\item[{\em gco}]-\/ options for the genetic optimisation. (see above). If gco == NULL, then a default set of options are used.\item[{\em userdata}]-\/ an (optional) pointer that is passed to the fitfunction, costfunction and updatefunction. Use this pointer to give extra information to your functions. \end{DoxyParams}
\hypertarget{gencurvefit_8c_a335a4f02a913cc610bc39e6f6ede5cfc}{
\index{gencurvefit.c@{gencurvefit.c}!gnoise@{gnoise}}
\index{gnoise@{gnoise}!gencurvefit.c@{gencurvefit.c}}
\subsubsection[{gnoise}]{\setlength{\rightskip}{0pt plus 5cm}double gnoise (
\begin{DoxyParamCaption}
\item[{struct {\bf mt19937p} $\ast$}]{ myMT19937, }
\item[{double}]{ sd}
\end{DoxyParamCaption}
)}}
\label{gencurvefit_8c_a335a4f02a913cc610bc39e6f6ede5cfc}
\hypertarget{gencurvefit_8c_a4cbd1f9b06be6e5d4f33e58b4d2cb134}{
\index{gencurvefit.c@{gencurvefit.c}!malloc2d@{malloc2d}}
\index{malloc2d@{malloc2d}!gencurvefit.c@{gencurvefit.c}}
\subsubsection[{malloc2d}]{\setlength{\rightskip}{0pt plus 5cm}void$\ast$ malloc2d (
\begin{DoxyParamCaption}
\item[{int}]{ ii, }
\item[{int}]{ jj, }
\item[{int}]{ sz}
\end{DoxyParamCaption}
)}}
\label{gencurvefit_8c_a4cbd1f9b06be6e5d4f33e58b4d2cb134}
Create a two-\/dimensional array in a single allocation

The effect is the same as an array of \char`\"{}element p\mbox{[}ii\mbox{]}\mbox{[}jj\mbox{]};
 The equivalent declaration is \char`\"{}element$\ast$$\ast$ p;" The array is created as an array of pointer to element, followed by an array of arrays of elements. 
\begin{DoxyParams}{Parameters}
\item[{\em ii}]first array bound \item[{\em jj}]second array bound \item[{\em sz}]size in bytes of an element of the 2d array \end{DoxyParams}
\begin{DoxyReturn}{Returns}
NULL on error or pointer to array
\end{DoxyReturn}
assign return value to (element$\ast$$\ast$)

to use this in practice one would write

double $\ast$$\ast$pp = NULL; pp = (double$\ast$$\ast$)malloc2d(5, 11, sizeof(double)); if(pp==NULL) return NOMEM;

$<$use pp=\char`\"{}\char`\"{} as=\char`\"{}\char`\"{} required$>$=\char`\"{}\char`\"{}$>$ free(pp);

Note you can access elements by ($\ast$(p+i)+j) is equivalent to p\mbox{[}i\mbox{]}\mbox{[}j\mbox{]} In addition $\ast$(p+i) points to a whole row. \hypertarget{gencurvefit_8c_a12c9b16ff375eafa5ceff3ad8f783548}{
\index{gencurvefit.c@{gencurvefit.c}!robust@{robust}}
\index{robust@{robust}!gencurvefit.c@{gencurvefit.c}}
\subsubsection[{robust}]{\setlength{\rightskip}{0pt plus 5cm}double robust (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{ userdata, }
\item[{const double $\ast$}]{ coefs, }
\item[{unsigned int}]{ numcoefs, }
\item[{const double $\ast$}]{ data, }
\item[{const double $\ast$}]{ model, }
\item[{const double $\ast$}]{ errors, }
\item[{long}]{ datapoints}
\end{DoxyParamCaption}
)}}
\label{gencurvefit_8c_a12c9b16ff375eafa5ceff3ad8f783548}
a default robust cost function


\begin{DoxyParams}{Parameters}
\item[{\em userdata}]-\/ an (optional) pointer that is passed to the fitfunction, costfunction and updatefunction. Use this pointer to give extra information to your functions.\item[{\em coefs\mbox{[}numcoefs\mbox{]}}]-\/ an array containing the coefficients for the fit.\item[{\em numcoefs}]-\/ the number of parameters being fitted.\item[{\em data\mbox{[}datapoints\mbox{]}}]-\/ the data points being fitted.\item[{\em model\mbox{[}datapoints\mbox{]}}]-\/ the model values calculated by the fitfunction.\item[{\em errors\mbox{[}datapoints\mbox{]}}]-\/ the error bars (standard deviation) corresponding to each of the datapoints.\item[{\em datapoints}]-\/ the number of datapoints being fitted. \end{DoxyParams}
